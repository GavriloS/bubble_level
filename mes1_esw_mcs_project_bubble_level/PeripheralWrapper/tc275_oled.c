/**********************************************************************************************************************
 * \file tc275_oled.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "tc275_oled.h"
#include "IfxQspi_SpiMaster.h"
#include "IfxPort.h"
#include "IfxStm.h" // For delay

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define IFX_INTPRIO_QSPI1_TX  10
#define IFX_INTPRIO_QSPI1_RX  11
#define IFX_INTPRIO_QSPI1_ER  12

// --- Hardware Pin Definitions (From your Slot 2 Diagram) ---
// Reset = P10.4, DC = P13.2
#define OLED_RST  &MODULE_P10, 4
#define OLED_DC   &MODULE_P13, 2


/*
*********************************************************************************************************
*                                             REMAMP
*********************************************************************************************************
*/

#define HIGH 1
#define LOW 0

#define _OLEDC_RMP_INC_HOR         0x00
#define _OLEDC_RMP_INC_VER         0x01
#define _OLEDC_RMP_COLOR_NOR       0x00
#define _OLEDC_RMP_COLOR_REV       0x02
#define _OLEDC_RMP_SEQ_RGB         0x00
#define _OLEDC_RMP_SEQ_BGR         0x04
#define _OLEDC_RMP_SCAN_NOR        0x00
#define _OLEDC_RMP_SCAN_REV        0x10
#define _OLEDC_RMP_SPLIT_DISABLE   0x00
#define _OLEDC_RMP_SPLIT_ENABLE    0x20
#define _OLEDC_COLOR_65K           0x00
#define _OLEDC_COLOR_262K          0x80
#define _OLEDC_IMG_HEAD            0x06

#define  _OLEDC_ROW_OFF          0x00
#define  _OLEDC_COL_OFF          0x10

/*
*********************************************************************************************************
*                                             OLED SETTINGS
*********************************************************************************************************
*/
static const uint8  _OLEDC_SCREEN_WIDTH    = 0x60;
static const uint8  _OLEDC_SCREEN_HEIGHT   = 0x60;


/*
*********************************************************************************************************
*                                             COMMANDS
*********************************************************************************************************
*/

/**
 * @name SSD1351 command bytes
 * @brief SSD1351 controller command opcodes used by the OLED C Click.
 */
static const uint8  _OLEDC_SET_COL_ADDRESS   = 0x15;
static const uint8  _OLEDC_SET_ROW_ADDRESS   = 0x75;
static const uint8  _OLEDC_WRITE_RAM         = 0x5C;
static const uint8  _OLEDC_SET_REMAP         = 0xA0;
static const uint8  _OLEDC_SET_START_LINE    = 0xA1;
static const uint8  _OLEDC_SET_OFFSET        = 0xA2;
static const uint8  _OLEDC_MODE_NORMAL       = 0xA6;
static const uint8  _OLEDC_SLEEP_ON          = 0xAE;
static const uint8  _OLEDC_SLEEP_OFF         = 0xAF;
static const uint8  _OLEDC_SET_RESET_PRECH  = 0xB1;
static const uint8  _OLEDC_CLOCK_DIV         = 0xB3;
static const uint8  _OLEDC_VSL               = 0xB4;

static const uint8  _OLEDC_SETSEC_PRECH      = 0xB6;
static const uint8  _OLEDC_VCOMH             = 0xBE;
static const uint8  _OLEDC_CONTRAST          = 0xC1;
static const uint8  _OLEDC_MASTER_CONTRAST   = 0xC7;
static const uint8  _OLEDC_MUX_RATIO         = 0xCA;
static const uint8  _OLEDC_COMMAND_LOCK      = 0xFD;

/**
 * @brief Default SSD1351 configuration values (written during initialization).
 */
static uint8 _OLEDC_DEFAULT_MUX_RATIO      = 95;
static uint8 _OLEDC_DEFAULT_START_LINE     = 0x80;
static uint8 _OLEDC_DEFAULT_OFFSET         = 0x20;

static uint8 _OLEDC_DEFAULT_OLED_LOCK      = 0x12;
static uint8 _OLEDC_DEFAULT_CMD_LOCK       = 0xB1;
static uint8 _OLEDC_DEFAULT_DIVSET         = 0xF1;
static uint8 _OLEDC_DEFAULT_PRECHARGE      = 0x32;
static uint8 _OLEDC_DEFAULT_VCOMH          = 0x05;
static uint8 _OLEDC_DEFAULT_MASTER_CONT    = 0xCF;
static uint8 _OLEDC_DEFAULT_PRECHARGE_2    = 0x01;


static uint8 _OLEDC_DEFAULT_REMAP = _OLEDC_RMP_INC_HOR | _OLEDC_RMP_COLOR_REV |
                                _OLEDC_RMP_SEQ_RGB | _OLEDC_RMP_SCAN_REV |
                                _OLEDC_RMP_SPLIT_ENABLE | _OLEDC_COLOR_65K;

static  uint8 _OLEDC_DEFAULT_VSL[ 3 ]       = { 0xA0, 0xB5, 0x55 };
static  uint8 _OLEDC_DEFAULT_CONTRAST[ 3 ]  = { 0x8A, 0x51, 0x8A };


/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
/**
 * @brief QSPI1 module instance (non-static for potential external access).
 *
 * Used to drive the SSD1351 OLED controller via the iLLD SPI master API.
 */
IfxQspi_SpiMaster g_qspi2_handle; // Global handle for the module

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
/**
 * @brief QSPI1 SPI master driver state for this module.
 */
static IfxQspi_SpiMaster g_qspi;

/**
 * @brief QSPI1 channel configuration/handle for the OLED device (chip-select, baudrate, mode).
 */
static IfxQspi_SpiMaster_Channel g_qspiChannel;

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
static void oledc_command(uint8 cmd, uint8 *args, uint16 args_len);
static void oledc_reset(void);
static void oledc_enable(uint8 state);
static void set_window(uint8 start_col, uint8 start_row, uint8 end_col, uint8 end_row);
static void init_OLED_GPIO(void);
static void init_QSPI1_Module(void);
static void init_set_driver_configuration(void);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

/**
 * @brief QSPI1 transmit interrupt service routine.
 *
 * Handles transmit events for QSPI1 by delegating to the
 * Infineon SPI master transmit ISR handler.
 */
IFX_INTERRUPT(qspi1TxISR, 0, IFX_INTPRIO_QSPI1_TX) { IfxQspi_SpiMaster_isrTransmit(&g_qspi); }

/**
 * @brief QSPI1 receive interrupt service routine.
 *
 * Handles receive events for QSPI1 by delegating to the
 * Infineon SPI master receive ISR handler.
 */
IFX_INTERRUPT(qspi1RxISR, 0, IFX_INTPRIO_QSPI1_RX) { IfxQspi_SpiMaster_isrReceive(&g_qspi); }

/**
 * @brief QSPI1 error interrupt service routine.
 *
 * Handles error conditions for QSPI1 by delegating to the
 * Infineon SPI master error ISR handler.
 */
IFX_INTERRUPT(qspi1ErISR, 0, IFX_INTPRIO_QSPI1_ER) { IfxQspi_SpiMaster_isrError(&g_qspi); }

/*
// --- Helper: Delay ---
void delay_ms(uint32 ms) {
    IfxStm_waitTicks(&MODULE_STM0, IfxStm_getTicksFromMilliseconds(&MODULE_STM0, ms));
}
*/


// ################
// global functions
// ################


// --- Initialization ---


/**
 * @brief Initialize OLED C Click (SSD1351) interface.
 *
 * High-level initialization function that:
 * 1. Configures QSPI hardware and pins.
 * 2. Configures GPIO for Reset and Data/Command control.
 * 3. Enables the display
 * 4. Performs a hardware reset of the display.
 * 5. Sends the SSD1351 startup command sequence.
 */
void oledc_init(void) {
    /* Configure QSPI1 as SPI master for SSD1351. */
    init_QSPI1_Module();

    /* Configure RST/DC GPIOs. */
    init_OLED_GPIO();

    /* Enable SSD1351 controller. */
    oledc_enable(HIGH);
    
    /* Reset SSD1351 controller. */
    oledc_reset();

    /* Apply default SSD1351 initialization sequence. */
    init_set_driver_configuration();
}

/**
 * @brief OLED C rectangle
 *
 * @param[in] start_col     start column coordinate
 * @param[in] start_row     start row coordinate
 * @param[in] end_col       end column cordinate
 * @param[in] end_row       end row coordinate
 * @param[in] color         color of rectangle
 *
 * Draw a filled rectangle from start coordiantes to end coordinates
 */
void oledc_rectangle(uint8 start_col, uint8 start_row, uint8 end_col, uint8 end_row, uint16 color) {
    // Clamp coordinates to screen boundaries to prevent memory overflow
    if (end_col >= _OLEDC_SCREEN_WIDTH) end_col = _OLEDC_SCREEN_WIDTH - 1;
    if (end_row >= _OLEDC_SCREEN_HEIGHT) end_row = _OLEDC_SCREEN_HEIGHT - 1;
    
    // Define the write area on the OLED controller
    set_window(start_col, start_row, end_col, end_row);

    // Calculate total pixels and prepare the color buffer (High Byte, Low Byte)
    uint32 count = (end_col - start_col + 1) * (end_row - start_row + 1);
    uint8 colorBytes[2] = {(color >> 8) & 0xFF, color & 0xFF};

    // Stream 16-bit color for each pixel in the window. 
    for (uint32 i = 0; i < count; i++) {
        IfxQspi_SpiMaster_exchange(&g_qspiChannel, colorBytes, NULL_PTR, 2);
        // Wait for transfer to complete before sending next pixel
        while (IfxQspi_SpiMaster_getStatus(&g_qspiChannel) == IfxQspi_Status_busy);
    }
}

/**
 * @brief OLED C fill screen
 *
 * @param[in] color     color choice
 *
 * Fill screen with specified color
 */
void oledc_fill_screen(uint16 color) {
    oledc_rectangle(0, 0, 95, 95, color);
}

/**
 * @brief OLED C line
 *
 * @param[in] start_col     start column coordinate
 * @param[in] start_row     start row coordinate
 * @param[in] end_col       end column cordinate
 * @param[in] end_row       end row coordinate
 * @param[in] color         color of line
 *
 * Draw a line from specified coordinates to other coordinates with specified color.
 * Note: Diagonal lines not supported by this implementation.
 */
void oledc_line(uint8 x1, uint8 y1, uint8 x2, uint8 y2, uint16 color) {
    // Determine if line is vertical or horizontal
    if (x1 == x2) {
        // Vertical Line: Ensure y1 < y2 for loop/rectangle logic
        if (y1 > y2) { uint8 t = y1; y1 = y2; y2 = t; }
        oledc_rectangle(x1, y1, x1, y2, color);
    } else if (y1 == y2) {
        // Horizontal Line: Ensure x1 < x2
        if (x1 > x2) { uint8 t = x1; x1 = x2; x2 = t; }
        oledc_rectangle(x1, y1, x2, y1, color);
    }
}

/**
 * @brief OLED C hud
 *
 * Draw white crosshair
 */
void oledc_hud(void) {
    // Draw whitw crosshairs (center is 48,48)
    oledc_line(48, 0, 48, 95, OLEDC_COLOR_WHITE);
    oledc_line(0, 48, 95, 48, OLEDC_COLOR_WHITE);
}


// ################
// static functions
// ################


/**
 * @brief OLED C set window
 *
 * @param[in] start_col     start column coordinate
 * @param[in] start_row     start row coordinate
 * @param[in] end_col       end column cordinate
 * @param[in] end_row       end row coordinate
 *
 * Set drawable window for oled c coordinates in ram
 */
static void set_window(uint8 start_col, uint8 start_row, uint8 end_col, uint8 end_row) {
    /* Convert logical coordinates to controller address space (with offsets). */
    uint8 cols[2] = {_OLEDC_COL_OFF + start_col, _OLEDC_COL_OFF + end_col};
    uint8 rows[2] = {_OLEDC_ROW_OFF + start_row, _OLEDC_ROW_OFF + end_row};

    // Send Set Column and Set Row commands
    oledc_command(_OLEDC_SET_COL_ADDRESS, cols, 2);
    oledc_command(_OLEDC_SET_ROW_ADDRESS, rows, 2);

    /* After setting column/row range, switch to RAM write mode. */
    uint8 cmd = _OLEDC_WRITE_RAM;
    IfxPort_setPinLow(OLED_DC);
    IfxQspi_SpiMaster_exchange(&g_qspiChannel, &cmd, NULL_PTR, 1);
    while (IfxQspi_SpiMaster_getStatus(&g_qspiChannel) == IfxQspi_Status_busy);
    
    // Set DC High. Any subsequent data sent via SPI is now interpreted as pixel data
    IfxPort_setPinHigh(OLED_DC);
}

/**
 * @brief OLED C enable
 *
 * @param[in] state (1 = on, 0 = off)
 *
 * Set the enable pin high or low, aka on or off
 */
static void oledc_enable(uint8 state){
    if (state == HIGH){
        IfxPort_setPinHigh(OLED_DC);
    } else {
        IfxPort_setPinLow(OLED_DC);
    }
}

/**
 * @brief OLED C command
 *
 * @param[in] command         hex command
 * @param[in] args            pointer to command
 * @param[in] args_len        length of command
 *
 * This is how you communicate with the SSD1351. Sends commands via SPI
 */
static void oledc_command(uint8 cmd, uint8 *args, uint16 args_len) {
    // 1. Send Command Byte
    IfxPort_setPinLow(OLED_DC); // DC Low = Command

    IfxQspi_SpiMaster_exchange(&g_qspiChannel, &cmd, NULL_PTR, 1);
    while (IfxQspi_SpiMaster_getStatus(&g_qspiChannel) == IfxQspi_Status_busy);

    IfxPort_setPinHigh(OLED_DC); // DC Low = Command

    // 2. Send Arguments (if any)
    if (args_len > 0 && args != NULL_PTR) {
        // IfxPort_setPinHigh(OLED_DC); // DC High = Data (Args are data)
        IfxQspi_SpiMaster_exchange(&g_qspiChannel, args, NULL_PTR, args_len);
        while (IfxQspi_SpiMaster_getStatus(&g_qspiChannel) == IfxQspi_Status_busy);
    }
}

/**
 * @brief OLED C reset
 *
 * Reset sequence as specified by datasheet
 */
static void oledc_reset(void) {
    IfxPort_setPinHigh(OLED_RST);
    IfxStm_waitTicks(&MODULE_STM0, IfxStm_getTicksFromMilliseconds(&MODULE_STM0, 1));
    IfxPort_setPinLow(OLED_RST);
    IfxStm_waitTicks(&MODULE_STM0, IfxStm_getTicksFromMilliseconds(&MODULE_STM0, 1));
    IfxPort_setPinHigh(OLED_RST);
    IfxStm_waitTicks(&MODULE_STM0, IfxStm_getTicksFromMilliseconds(&MODULE_STM0, 100));
}

/**
 * @brief OLED C gpio init
 *
 * Init the oled c gpio pins
 */
static void init_OLED_GPIO(void) {
    // Configure RST and D/C as push-pull outputs. 
    IfxPort_setPinModeOutput(OLED_RST, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(OLED_DC,  IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

    // Set default state (High)
    IfxPort_setPinHigh(OLED_RST);
}

/**
 * @brief QSPI1 init
 *
 * Init the QSPI1 module
 */
static void init_QSPI1_Module(void) {
    // Initialize Module Configuration Structure with default values
    IfxQspi_SpiMaster_Config spiMasterConfig;
    IfxQspi_SpiMaster_initModuleConfig(&spiMasterConfig, &MODULE_QSPI1);

    // Set Master Mode and Interrupt Priorities
    spiMasterConfig.mode             = IfxQspi_Mode_master;
    spiMasterConfig.maximumBaudrate  = 20000000; // 20 MHz
    spiMasterConfig.txPriority       = 10; // Ensure ISRs are installed in main!
    spiMasterConfig.rxPriority       = 11;
    spiMasterConfig.erPriority       = 12;
    spiMasterConfig.isrProvider      = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

    // Assign QSPI1 pins for SCLK/MOSI/MISO.
    const IfxQspi_SpiMaster_Pins pins = {
        .sclk = &IfxQspi1_SCLK_P10_2_OUT, .sclkMode = IfxPort_OutputMode_pushPull,
        .mtsr = &IfxQspi1_MTSR_P10_3_OUT, .mtsrMode = IfxPort_OutputMode_pushPull,
        .mrst = &IfxQspi1_MRSTA_P10_1_IN, .mrstMode = IfxPort_InputMode_pullUp,
        .pinDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    spiMasterConfig.pins = &pins;
    IfxQspi_SpiMaster_initModule(&g_qspi, &spiMasterConfig);

    // Configure the OLED chip-select line and SPI timing. 
    IfxQspi_SpiMaster_ChannelConfig channelConfig;
    IfxQspi_SpiMaster_initChannelConfig(&channelConfig, &g_qspi);
    channelConfig.ch.baudrate = 10000000; // 10 MHz
    channelConfig.sls.output.pin    = &IfxQspi1_SLSO9_P10_5_OUT;
    channelConfig.sls.output.mode   = IfxPort_OutputMode_pushPull;
    channelConfig.sls.output.driver = IfxPort_PadDriver_cmosAutomotiveSpeed1;
    channelConfig.ch.mode.dataHeading = IfxQspi_DataHeading_msbFirst; // Standard SPI

    IfxQspi_SpiMaster_initChannel(&g_qspiChannel, &channelConfig);
}

/**
 * @brief Write the SSD1351 initialization sequence.
 *
 * Sends the configuration commands required to put the display into a known
 * state (addressing mode, contrast, precharge, etc.).
 */
static void init_set_driver_configuration(void){
    // Apply default driver configuration values. 

    // Unlock command entry
    oledc_command( _OLEDC_COMMAND_LOCK,    &_OLEDC_DEFAULT_OLED_LOCK,     1 );
    oledc_command( _OLEDC_COMMAND_LOCK,    &_OLEDC_DEFAULT_CMD_LOCK,      1 );
    
    // Turn off sleep mode (display off) during config
    oledc_command( _OLEDC_SLEEP_ON,        0,                      0 );
    
    // Configure Memory Mapping, MUX Ratio, and Start Line
    oledc_command( _OLEDC_SET_REMAP,       &_OLEDC_DEFAULT_REMAP,         1 );
    oledc_command( _OLEDC_MUX_RATIO,       &_OLEDC_DEFAULT_MUX_RATIO,     1 );
    oledc_command( _OLEDC_SET_START_LINE,  &_OLEDC_DEFAULT_START_LINE,    1 );
    oledc_command( _OLEDC_SET_OFFSET,      &_OLEDC_DEFAULT_OFFSET,        1 );

    // Configure Power / voltages / Clock
    oledc_command( _OLEDC_VCOMH,           &_OLEDC_DEFAULT_VCOMH,         1 );
    oledc_command( _OLEDC_CLOCK_DIV,       &_OLEDC_DEFAULT_DIVSET,        1 );
    oledc_command( _OLEDC_SET_RESET_PRECH, &_OLEDC_DEFAULT_PRECHARGE,     1 );
    oledc_command( _OLEDC_SETSEC_PRECH,    &_OLEDC_DEFAULT_PRECHARGE_2,   1 );

    // Configure Contrast and Gray Scale
    oledc_command( _OLEDC_MASTER_CONTRAST, &_OLEDC_DEFAULT_MASTER_CONT,   1 );
    oledc_command( _OLEDC_CONTRAST,        _OLEDC_DEFAULT_CONTRAST,       3 );
    oledc_command( _OLEDC_VSL,             _OLEDC_DEFAULT_VSL,            3 );

    // Set Display Mode to Normal and wake up
    oledc_command(_OLEDC_MODE_NORMAL, 0, 0);
    oledc_command(_OLEDC_SLEEP_OFF, 0, 0);
}
