/**********************************************************************************************************************
 * \file tc275_c6dofimu.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "tc275_c6dofimu.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
static IfxI2c_I2c i2c;
static IfxI2c_I2c_Device i2cDev;

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
static sint16 map(sint16 x, sint16 in_min, sint16 in_max, sint16 out_min, sint16 out_max) {
      return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    }

IfxI2c_I2c_Status write_register(IfxI2c_I2c_Device *device, uint8 reg_addr, uint8 value) {
    uint8 tx_buf[2];
    tx_buf[0] = reg_addr; // First byte is the register address
    tx_buf[1] = value;    // Second byte is the data

    // device, buffer, length
    return IfxI2c_I2c_write(device, tx_buf, 2);
}

IfxI2c_I2c_Status c6dofimu14_init(void){
    /* create config structure */
       IfxI2c_I2c_Config config;
       // fill structure with default values and Module address
       IfxI2c_I2c_initConfig(&config, &MODULE_I2C0);

       /* configure pins */
       const IfxI2c_Pins pins = {
       &IfxI2c0_SCL_P02_5_INOUT,
       &IfxI2c0_SDA_P02_4_INOUT,
       IfxPort_PadDriver_cmosAutomotiveSpeed1
       };
       config.pins = &pins;
       config.baudrate = 100000; /* 100 kHz */

       /* initialize module */
       IfxI2c_I2c_initModule(&i2c, &config);
       IfxI2c_I2c_deviceConfig i2cDeviceConfig;
       // fill structure with default values and i2c Handler
       IfxI2c_I2c_initDeviceConfig(&i2cDeviceConfig, &i2c);

       /* set device specifig values */
       i2cDeviceConfig.deviceAddress = C6DOFIMU14_ADDRESS << 1;

       /* initialize the i2c device handle */
       IfxI2c_I2c_initDevice(&i2cDev, &i2cDeviceConfig);

       uint8 tmp_data;
       IfxI2c_I2c_Status status;
       // 1. Soft Reset
       tmp_data = C6DOFIMU14_DEVCONFIG_SOFT_RESET_ENABLE;
       status = write_register(&i2cDev, C6DOFIMU14_REG0_DEVICE_CONFIG, tmp_data);

       // Use uC/OS delay for the chip to reboot

       IfxStm_waitTicks(&MODULE_STM0, IfxStm_getTicksFromMilliseconds(&MODULE_STM0, 100));

       // 2. Drive Config
       tmp_data = C6DOFIMU14_DRIVECONFIG_MIN_SLEW_RATE;
       write_register(&i2cDev, C6DOFIMU14_REG0_DRIVE_CONFIG, tmp_data);

       // 3. WHO_AM_I Check (with a safety timeout for AURIX)
       // --- 2. WHO_AM_I Check (Corrected for AURIX iLLD) ---
           uint32 retries = 50;
           tmp_data = 0;
           uint8 reg_to_read = C6DOFIMU14_REG0_WHO_AM_I; // The register address byte

           while (tmp_data != C6DOFIMU14_DEF_WHO_AM_I) {
               // STEP A: Tell the IMU we want to read the WHO_AM_I register
               status = IfxI2c_I2c_write(&i2cDev, &reg_to_read, 1);

               if (status == IfxI2c_I2c_Status_ok) {
                   // STEP B: Now read the 1-byte result from the IMU
                   status = IfxI2c_I2c_read(&i2cDev, &tmp_data, 1);
               }

               // Safety exit: if we run out of retries or get a major bus error
               if (--retries == 0) {
                   return IfxI2c_I2c_Status_error;
               }

               // If the device isn't ready yet, wait 5ms and try again
               if (tmp_data != C6DOFIMU14_DEF_WHO_AM_I) {
                   IfxStm_waitTicks(&MODULE_STM0, IfxStm_getTicksFromMilliseconds(&MODULE_STM0, 5));
               }
           }

       // 4. Power Management - Set to Low Noise Mode
       tmp_data = C6DOFIMU14_PWR_TEMP_DISABLE | C6DOFIMU14_PWR_IDLE_1 |
                  C6DOFIMU14_PWR_GYRO_MODE_OFF | C6DOFIMU14_PWR_ACCEL_MODE_LOW_NOISE;
       write_register(&i2cDev, C6DOFIMU14_REG0_PWR_MGMT_0, tmp_data);

       // Critical: Let sensors stabilize before configuring FS/ODR
       IfxStm_waitTicks(&MODULE_STM0, IfxStm_getTicksFromMilliseconds(&MODULE_STM0, 50));

       // 5. Sensor Configuration
       tmp_data = C6DOFIMU14_ACFG0_FS_SEL_16G | C6DOFIMU14_ACFG0_ODR_1KHZ;
       write_register(&i2cDev, C6DOFIMU14_REG0_ACCEL_CONFIG_0, tmp_data);

       tmp_data = C6DOFIMU14_GCFG0_FS_SEL_2000DPS | C6DOFIMU14_GCFG0_ODR_1KHZ;
       write_register(&i2cDev, C6DOFIMU14_REG0_GYRO_CONFIG_0, tmp_data);

       // 6. FIFO Setup
       tmp_data = C6DOFIMU14_FIFOCONFIG_STREAM_TO_FIFO_MODE;
       write_register(&i2cDev, C6DOFIMU14_REG0_FIFO_CONFIG, tmp_data);

       tmp_data = C6DOFIMU14_FIFOCONFIG1_TEMP_EN | C6DOFIMU14_FIFOCONFIG1_GYRO_EN | C6DOFIMU14_FIFOCONFIG1_ACCEL_EN;
       write_register(&i2cDev, C6DOFIMU14_REG0_FIFO_CONFIG_1, tmp_data);
       return IfxI2c_I2c_Status_ok;
}



static uint8 c6dofimu14_check_data_ready() {
    uint8 tmp_data;
    uint16 timeout_cnt = 0;
    uint8 reg_addr = C6DOFIMU14_REG0_INT_STATUS_1;
    IfxI2c_I2c_Status status;
    for ( ; ; )
    {
        // STEP 1: Tell IMU we want to read INT_STATUS_1
        IfxI2c_I2c_write(&i2cDev, &reg_addr, 1);

        // STEP 2: Read the status byte
        status = IfxI2c_I2c_read(&i2cDev, &tmp_data, 1);
        IfxStm_waitTicks(&MODULE_STM0, IfxStm_getTicksFromMilliseconds(&MODULE_STM0, 100));
        // Check Bit 3: DATA_RDY_INT
        if ((status == IfxI2c_I2c_Status_ok) && (tmp_data & 0x08))
        {
            return C6DOFIMU14_OK;
        }

        if (timeout_cnt++ > 100) // Adjusted timeout for better responsiveness
        {
            return C6DOFIMU14_ERR;
        }
    }
    return C6DOFIMU14_ERR;
}

void c6dofimu14_read_accel_axis(c6dofimu14_axis_t *axis) {
    uint8 reg_addr = C6DOFIMU14_REG0_ACCEL_X_MSB; // Starting register
    uint8 data_buf[6]; // Buffer to hold X_MSB, X_LSB, Y_MSB, Y_LSB, Z_MSB, Z_LSB
    sint16 raw_x, raw_y, raw_z;
    IfxI2c_I2c_Status status;

    // 1. Wait for Data Ready (Avoid infinite while loop in RTOS)
    // Assuming c6dofimu14_check_data_ready is updated to use the 2-step read logic
    while (c6dofimu14_check_data_ready() != C6DOFIMU14_OK) {
        // Use your waitticks here to prevent hogging the CPU
        // waitTicks(1);
    }

    // 2. BURST READ: Set starting address then read 6 bytes
    // Step A: Write the starting register address
    IfxI2c_I2c_write(&i2cDev, &reg_addr, 1);

    // Step B: Read all 6 bytes in one transaction
    status = IfxI2c_I2c_read(&i2cDev, data_buf, 6);

    if (status == IfxI2c_I2c_Status_ok) {
        // 3. Reconstruct 16-bit signed integers from bytes
        // Data format: [0]=X_MSB, [1]=X_LSB, [2]=Y_MSB, [3]=Y_LSB, [4]=Z_MSB, [5]=Z_LSB
        raw_x = (sint16)((data_buf[0] << 8) | data_buf[1]);
        raw_y = (sint16)((data_buf[2] << 8) | data_buf[3]);
        raw_z = (sint16)((data_buf[4] << 8) | data_buf[5]);

        // 4. Map the raw values to OLED coordinates
        // Using your map function logic
        axis->x = map(raw_x, C6DOFIMU14_ACCEL_MIN, C6DOFIMU14_ACCEL_MAX, OLED_X_MIN, OLED_X_MAX);
        axis->y = map(raw_y, C6DOFIMU14_ACCEL_MIN, C6DOFIMU14_ACCEL_MAX, OLED_Y_MIN, OLED_Y_MAX);
        axis->y = OLED_Y_MAX - axis->y;
        axis->z = map(raw_z, C6DOFIMU14_ACCEL_MIN, C6DOFIMU14_ACCEL_MAX, OLED_X_MIN, OLED_X_MAX);
    }
}
